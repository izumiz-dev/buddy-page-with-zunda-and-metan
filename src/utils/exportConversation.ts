import { Conversation, Character } from '../types';

/**
 * Generates a Markdown string from conversation data and metadata.
 * @param conversation The conversation object.
 * @param pageTitle The title of the original web page.
 * @param pageUrl The URL of the original web page.
 * @param generatedAt The timestamp when the conversation was generated.
 * @returns The formatted Markdown string.
 */
function generateMarkdown(
  conversation: Conversation,
  pageTitle: string,
  pageUrl: string,
  generatedAt: Date
): string {
  // Format date as YYYY/MM/DD HH:mm:ss
  const formattedDate = generatedAt.toLocaleString('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false // Use 24-hour format
  }).replace(/\//g, '/'); // Ensure slashes if locale uses different separators

  const modeText = (conversation.mode === 'professional') ? 'プロフェッショナル' : 'カジュアル';

  const intro = `以下のページについて、ずんだもんと四国めたんがお話しました。\n`;
  const metadata = `
- **タイトル:** ${pageTitle || 'タイトル不明'}
- **URL:** ${pageUrl || 'N/A'}
- **作成日時:** ${formattedDate}
- **モード:** ${modeText}
`;

  const conversationLines = conversation.lines
    .map(line => {
      const speaker = line.character === Character.ZUNDAMON ? 'ずんだもん' : '四国めたん';
      return `**${speaker}:** ${line.text}\n`;
    })
    .join('\n');

  const footer = `
---
Generated by ZundaMetan Navigator (https://github.com/izumiz-dev/buddy-page-with-zunda-and-metan)`;

  return `${intro}\n${metadata}\n\n---\n\n## 会話\n\n${conversationLines}\n${footer}`;
}

/**
 * Exports the conversation and metadata as a Markdown file.
 * @param conversation The conversation object.
 * @param pageTitle The title of the original web page.
 * @param pageUrl The URL of the original web page.
 * @param generatedAt The timestamp when the conversation was generated.
 */
export function exportConversationToMarkdown(
  conversation: Conversation,
  pageTitle: string,
  pageUrl: string,
  generatedAt: Date
): void {
  if (!conversation || !conversation.lines || conversation.lines.length === 0) {
    console.error('Cannot export empty or invalid conversation.');
    return;
  }

  const markdownContent = generateMarkdown(conversation, pageTitle, pageUrl, generatedAt);
  const blob = new Blob([markdownContent], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  // Format date as YYYYMMDD
  const year = generatedAt.getFullYear();
  const month = (generatedAt.getMonth() + 1).toString().padStart(2, '0');
  const day = generatedAt.getDate().toString().padStart(2, '0');
  const dateStamp = `${year}${month}${day}`;

  // Sanitize title for filename: Remove problematic chars, replace spaces, reduce underscores, trim
  let safeTitle = pageTitle || 'conversation';
  safeTitle = safeTitle
    .replace(/[\\/:*?"<>|]/g, '') // Remove problematic characters
    .replace(/\s+/g, '_') // Replace spaces with underscores
    .replace(/_+/g, '_') // Replace multiple underscores with single
    .replace(/^_+|_+$/g, ''); // Trim leading/trailing underscores
  
  // Limit length after sanitization
  safeTitle = safeTitle.substring(0, 80); // Increased length limit slightly

  // Get mode string
  const modeString = conversation.mode || 'casual';

  // Construct filename: [YYYYMMDD]_[SanitizedTitle]_[Mode].md
  const filename = `${dateStamp}_${safeTitle}_${modeString}.md`;

  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link); // Required for Firefox
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);

  console.log(`Conversation exported as ${filename}`);
}
